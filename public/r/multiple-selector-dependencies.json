{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "multiple-selector-dependencies",
  "type": "registry:ui",
  "title": "Multiple Selector Dependencies",
  "description": "component for the Multiple Selector Dependencies",
  "dependencies": [
    "cmdk",
    "lucide-react"
  ],
  "registryDependencies": [
    "badge",
    "command"
  ],
  "files": [
    {
      "path": "app/registry/spectrumui/multiple-selector-dependencies.tsx",
      "content": "'use client';\r\n\r\nimport { Command as CommandPrimitive, useCommandState } from 'cmdk';\r\nimport { X } from 'lucide-react';\r\nimport * as React from 'react';\r\nimport { forwardRef, useEffect } from 'react';\r\n\r\nimport { Badge } from '@/components/ui/badge';\r\nimport { Command, CommandGroup, CommandItem, CommandList } from '@/components/ui/command';\r\nimport { cn } from '@/lib/utils';\r\n\r\nexport interface Option {\r\n  value: string;\r\n  label: string;\r\n  disable?: boolean;\r\n  /** fixed option that can't be removed. */\r\n  fixed?: boolean;\r\n  /** Group the options by providing key. */\r\n  [key: string]: string | boolean | undefined;\r\n}\r\ninterface GroupOption {\r\n  [key: string]: Option[];\r\n}\r\n\r\ninterface MultipleSelectorProps {\r\n  value?: Option[];\r\n  defaultOptions?: Option[];\r\n  /** manually controlled options */\r\n  options?: Option[];\r\n  placeholder?: string;\r\n  /** Loading component. */\r\n  loadingIndicator?: React.ReactNode;\r\n  /** Empty component. */\r\n  emptyIndicator?: React.ReactNode;\r\n  /** Debounce time for async search. Only work with `onSearch`. */\r\n  delay?: number;\r\n  /**\r\n   * Only work with `onSearch` prop. Trigger search when `onFocus`.\r\n   * For example, when user click on the input, it will trigger the search to get initial options.\r\n   **/\r\n  triggerSearchOnFocus?: boolean;\r\n  /** async search */\r\n  onSearch?: (value: string) => Promise<Option[]>;\r\n  /**\r\n   * sync search. This search will not showing loadingIndicator.\r\n   * The rest props are the same as async search.\r\n   * i.e.: creatable, groupBy, delay.\r\n   **/\r\n  onSearchSync?: (value: string) => Option[];\r\n  onChange?: (options: Option[]) => void;\r\n  /** Limit the maximum number of selected options. */\r\n  maxSelected?: number;\r\n  /** When the number of selected options exceeds the limit, the onMaxSelected will be called. */\r\n  onMaxSelected?: (maxLimit: number) => void;\r\n  /** Hide the placeholder when there are options selected. */\r\n  hidePlaceholderWhenSelected?: boolean;\r\n  disabled?: boolean;\r\n  /** Group the options base on provided key. */\r\n  groupBy?: string;\r\n  className?: string;\r\n  badgeClassName?: string;\r\n  /**\r\n   * First item selected is a default behavior by cmdk. That is why the default is true.\r\n   * This is a workaround solution by add a dummy item.\r\n   *\r\n   * @reference: https://github.com/pacocoursey/cmdk/issues/171\r\n   */\r\n  selectFirstItem?: boolean;\r\n  /** Allow user to create option when there is no option matched. */\r\n  creatable?: boolean;\r\n  /** Props of `Command` */\r\n  commandProps?: React.ComponentPropsWithoutRef<typeof Command>;\r\n  /** Props of `CommandInput` */\r\n  inputProps?: Omit<\r\n    React.ComponentPropsWithoutRef<typeof CommandPrimitive.Input>,\r\n    'value' | 'placeholder' | 'disabled'\r\n  >;\r\n  /** hide the clear all button. */\r\n  hideClearAllButton?: boolean;\r\n}\r\n\r\nexport interface MultipleSelectorRef {\r\n  selectedValue: Option[];\r\n  input: HTMLInputElement;\r\n  focus: () => void;\r\n  reset: () => void;\r\n}\r\n\r\nexport function useDebounce<T>(value: T, delay?: number): T {\r\n  const [debouncedValue, setDebouncedValue] = React.useState<T>(value);\r\n\r\n  useEffect(() => {\r\n    const timer = setTimeout(() => setDebouncedValue(value), delay || 500);\r\n\r\n    return () => {\r\n      clearTimeout(timer);\r\n    };\r\n  }, [value, delay]);\r\n\r\n  return debouncedValue;\r\n}\r\n\r\nfunction transToGroupOption(options: Option[], groupBy?: string) {\r\n  if (options.length === 0) {\r\n    return {};\r\n  }\r\n  if (!groupBy) {\r\n    return {\r\n      '': options,\r\n    };\r\n  }\r\n\r\n  const groupOption: GroupOption = {};\r\n  options.forEach((option) => {\r\n    const key = (option[groupBy] as string) || '';\r\n    if (!groupOption[key]) {\r\n      groupOption[key] = [];\r\n    }\r\n    groupOption[key].push(option);\r\n  });\r\n  return groupOption;\r\n}\r\n\r\nfunction removePickedOption(groupOption: GroupOption, picked: Option[]) {\r\n  const cloneOption = JSON.parse(JSON.stringify(groupOption)) as GroupOption;\r\n\r\n  for (const [key, value] of Object.entries(cloneOption)) {\r\n    cloneOption[key] = value.filter((val) => !picked.find((p) => p.value === val.value));\r\n  }\r\n  return cloneOption;\r\n}\r\n\r\nfunction isOptionsExist(groupOption: GroupOption, targetOption: Option[]) {\r\n  for (const [, value] of Object.entries(groupOption)) {\r\n    if (value.some((option) => targetOption.find((p) => p.value === option.value))) {\r\n      return true;\r\n    }\r\n  }\r\n  return false;\r\n}\r\n\r\n/**\r\n * The `CommandEmpty` of shadcn/ui will cause the cmdk empty not rendering correctly.\r\n * So we create one and copy the `Empty` implementation from `cmdk`.\r\n *\r\n * @reference: https://github.com/hsuanyi-chou/shadcn-ui-expansions/issues/34#issuecomment-1949561607\r\n **/\r\nconst CommandEmpty = forwardRef<\r\n  HTMLDivElement,\r\n  React.ComponentProps<typeof CommandPrimitive.Empty>\r\n>(({ className, ...props }, forwardedRef) => {\r\n  const render = useCommandState((state) => state.filtered.count === 0);\r\n\r\n  if (!render) return null;\r\n\r\n  return (\r\n    <div\r\n      ref={forwardedRef}\r\n      className={cn('py-6 text-center text-sm', className)}\r\n      cmdk-empty=\"\"\r\n      role=\"presentation\"\r\n      {...props}\r\n    />\r\n  );\r\n});\r\n\r\nCommandEmpty.displayName = 'CommandEmpty';\r\n\r\nconst MultipleSelector = React.forwardRef<MultipleSelectorRef, MultipleSelectorProps>(\r\n  (\r\n    {\r\n      value,\r\n      onChange,\r\n      placeholder,\r\n      defaultOptions: arrayDefaultOptions = [],\r\n      options: arrayOptions,\r\n      delay,\r\n      onSearch,\r\n      onSearchSync,\r\n      loadingIndicator,\r\n      emptyIndicator,\r\n      maxSelected = Number.MAX_SAFE_INTEGER,\r\n      onMaxSelected,\r\n      hidePlaceholderWhenSelected,\r\n      disabled,\r\n      groupBy,\r\n      className,\r\n      badgeClassName,\r\n      selectFirstItem = true,\r\n      creatable = false,\r\n      triggerSearchOnFocus = false,\r\n      commandProps,\r\n      inputProps,\r\n      hideClearAllButton = false,\r\n    }: MultipleSelectorProps,\r\n    ref: React.Ref<MultipleSelectorRef>,\r\n  ) => {\r\n    const inputRef = React.useRef<HTMLInputElement>(null);\r\n    const [open, setOpen] = React.useState(false);\r\n    const [onScrollbar, setOnScrollbar] = React.useState(false);\r\n    const [isLoading, setIsLoading] = React.useState(false);\r\n    const dropdownRef = React.useRef<HTMLDivElement>(null); // Added this\r\n\r\n    const [selected, setSelected] = React.useState<Option[]>(value || []);\r\n    const [options, setOptions] = React.useState<GroupOption>(\r\n      transToGroupOption(arrayDefaultOptions, groupBy),\r\n    );\r\n    const [inputValue, setInputValue] = React.useState('');\r\n    const debouncedSearchTerm = useDebounce(inputValue, delay || 500);\r\n\r\n    React.useImperativeHandle(\r\n      ref,\r\n      () => ({\r\n        selectedValue: [...selected],\r\n        input: inputRef.current as HTMLInputElement,\r\n        focus: () => inputRef?.current?.focus(),\r\n        reset: () => setSelected([])\r\n      }),\r\n      [selected],\r\n    );\r\n\r\n    const handleClickOutside = (event: MouseEvent | TouchEvent) => {\r\n      if (\r\n        dropdownRef.current &&\r\n        !dropdownRef.current.contains(event.target as Node) &&\r\n        inputRef.current &&\r\n        !inputRef.current.contains(event.target as Node)\r\n      ) {\r\n        setOpen(false);\r\n        inputRef.current.blur();\r\n      }\r\n    };\r\n\r\n    const handleUnselect = React.useCallback(\r\n      (option: Option) => {\r\n        const newOptions = selected.filter((s) => s.value !== option.value);\r\n        setSelected(newOptions);\r\n        onChange?.(newOptions);\r\n      },\r\n      [onChange, selected],\r\n    );\r\n\r\n    const handleKeyDown = React.useCallback(\r\n      (e: React.KeyboardEvent<HTMLDivElement>) => {\r\n        const input = inputRef.current;\r\n        if (input) {\r\n          if (e.key === 'Delete' || e.key === 'Backspace') {\r\n            if (input.value === '' && selected.length > 0) {\r\n              const lastSelectOption = selected[selected.length - 1];\r\n              // If last item is fixed, we should not remove it.\r\n              if (!lastSelectOption.fixed) {\r\n                handleUnselect(selected[selected.length - 1]);\r\n              }\r\n            }\r\n          }\r\n          // This is not a default behavior of the <input /> field\r\n          if (e.key === 'Escape') {\r\n            input.blur();\r\n          }\r\n        }\r\n      },\r\n      [handleUnselect, selected],\r\n    );\r\n\r\n    useEffect(() => {\r\n      if (open) {\r\n        document.addEventListener('mousedown', handleClickOutside);\r\n        document.addEventListener('touchend', handleClickOutside);\r\n      } else {\r\n        document.removeEventListener('mousedown', handleClickOutside);\r\n        document.removeEventListener('touchend', handleClickOutside);\r\n      }\r\n\r\n      return () => {\r\n        document.removeEventListener('mousedown', handleClickOutside);\r\n        document.removeEventListener('touchend', handleClickOutside);\r\n      };\r\n    }, [open]);\r\n\r\n    useEffect(() => {\r\n      if (value) {\r\n        setSelected(value);\r\n      }\r\n    }, [value]);\r\n\r\n    useEffect(() => {\r\n      /** If `onSearch` is provided, do not trigger options updated. */\r\n      if (!arrayOptions || onSearch) {\r\n        return;\r\n      }\r\n      const newOption = transToGroupOption(arrayOptions || [], groupBy);\r\n      if (JSON.stringify(newOption) !== JSON.stringify(options)) {\r\n        setOptions(newOption);\r\n      }\r\n    }, [arrayDefaultOptions, arrayOptions, groupBy, onSearch, options]);\r\n\r\n    useEffect(() => {\r\n      /** sync search */\r\n\r\n      const doSearchSync = () => {\r\n        const res = onSearchSync?.(debouncedSearchTerm);\r\n        setOptions(transToGroupOption(res || [], groupBy));\r\n      };\r\n\r\n      const exec = async () => {\r\n        if (!onSearchSync || !open) return;\r\n\r\n        if (triggerSearchOnFocus) {\r\n          doSearchSync();\r\n        }\r\n\r\n        if (debouncedSearchTerm) {\r\n          doSearchSync();\r\n        }\r\n      };\r\n\r\n      void exec();\r\n      // eslint-disable-next-line react-hooks/exhaustive-deps\r\n    }, [debouncedSearchTerm, groupBy, open, triggerSearchOnFocus]);\r\n\r\n    useEffect(() => {\r\n      /** async search */\r\n\r\n      const doSearch = async () => {\r\n        setIsLoading(true);\r\n        const res = await onSearch?.(debouncedSearchTerm);\r\n        setOptions(transToGroupOption(res || [], groupBy));\r\n        setIsLoading(false);\r\n      };\r\n\r\n      const exec = async () => {\r\n        if (!onSearch || !open) return;\r\n\r\n        if (triggerSearchOnFocus) {\r\n          await doSearch();\r\n        }\r\n\r\n        if (debouncedSearchTerm) {\r\n          await doSearch();\r\n        }\r\n      };\r\n\r\n      void exec();\r\n      // eslint-disable-next-line react-hooks/exhaustive-deps\r\n    }, [debouncedSearchTerm, groupBy, open, triggerSearchOnFocus]);\r\n\r\n    const CreatableItem = () => {\r\n      if (!creatable) return undefined;\r\n      if (\r\n        isOptionsExist(options, [{ value: inputValue, label: inputValue }]) ||\r\n        selected.find((s) => s.value === inputValue)\r\n      ) {\r\n        return undefined;\r\n      }\r\n\r\n      const Item = (\r\n        <CommandItem\r\n          value={inputValue}\r\n          className=\"cursor-pointer\"\r\n          onMouseDown={(e) => {\r\n            e.preventDefault();\r\n            e.stopPropagation();\r\n          }}\r\n          onSelect={(value: string) => {\r\n            if (selected.length >= maxSelected) {\r\n              onMaxSelected?.(selected.length);\r\n              return;\r\n            }\r\n            setInputValue('');\r\n            const newOptions = [...selected, { value, label: value }];\r\n            setSelected(newOptions);\r\n            onChange?.(newOptions);\r\n          }}\r\n        >\r\n          {`Create \"${inputValue}\"`}\r\n        </CommandItem>\r\n      );\r\n\r\n      // For normal creatable\r\n      if (!onSearch && inputValue.length > 0) {\r\n        return Item;\r\n      }\r\n\r\n      // For async search creatable. avoid showing creatable item before loading at first.\r\n      if (onSearch && debouncedSearchTerm.length > 0 && !isLoading) {\r\n        return Item;\r\n      }\r\n\r\n      return undefined;\r\n    };\r\n\r\n    const EmptyItem = React.useCallback(() => {\r\n      if (!emptyIndicator) return undefined;\r\n\r\n      // For async search that showing emptyIndicator\r\n      if (onSearch && !creatable && Object.keys(options).length === 0) {\r\n        return (\r\n          <CommandItem value=\"-\" disabled>\r\n            {emptyIndicator}\r\n          </CommandItem>\r\n        );\r\n      }\r\n\r\n      return <CommandEmpty>{emptyIndicator}</CommandEmpty>;\r\n    }, [creatable, emptyIndicator, onSearch, options]);\r\n\r\n    const selectables = React.useMemo<GroupOption>(\r\n      () => removePickedOption(options, selected),\r\n      [options, selected],\r\n    );\r\n\r\n    /** Avoid Creatable Selector freezing or lagging when paste a long string. */\r\n    const commandFilter = React.useCallback(() => {\r\n      if (commandProps?.filter) {\r\n        return commandProps.filter;\r\n      }\r\n\r\n      if (creatable) {\r\n        return (value: string, search: string) => {\r\n          return value.toLowerCase().includes(search.toLowerCase()) ? 1 : -1;\r\n        };\r\n      }\r\n      // Using default filter in `cmdk`. We don't have to provide it.\r\n      return undefined;\r\n    }, [creatable, commandProps?.filter]);\r\n\r\n    return (\r\n      <Command\r\n        ref={dropdownRef}\r\n        {...commandProps}\r\n        onKeyDown={(e) => {\r\n          handleKeyDown(e);\r\n          commandProps?.onKeyDown?.(e);\r\n        }}\r\n        className={cn('h-auto overflow-visible bg-transparent', commandProps?.className)}\r\n        shouldFilter={\r\n          commandProps?.shouldFilter !== undefined ? commandProps.shouldFilter : !onSearch\r\n        } // When onSearch is provided, we don't want to filter the options. You can still override it.\r\n        filter={commandFilter()}\r\n      >\r\n        <div\r\n          className={cn(\r\n            'min-h-10 rounded-md border border-input text-sm ring-offset-background focus-within:ring-2 focus-within:ring-ring focus-within:ring-offset-2',\r\n            {\r\n              'px-3 py-2': selected.length !== 0,\r\n              'cursor-text': !disabled && selected.length !== 0,\r\n            },\r\n            className,\r\n          )}\r\n          onClick={() => {\r\n            if (disabled) return;\r\n            inputRef?.current?.focus();\r\n          }}\r\n        >\r\n          <div className=\"relative flex flex-wrap gap-1\">\r\n            {selected.map((option) => {\r\n              return (\r\n                <Badge\r\n                  key={option.value}\r\n                  className={cn(\r\n                    'data-[disabled]:bg-muted-foreground data-[disabled]:text-muted data-[disabled]:hover:bg-muted-foreground',\r\n                    'data-[fixed]:bg-muted-foreground data-[fixed]:text-muted data-[fixed]:hover:bg-muted-foreground',\r\n                    badgeClassName,\r\n                  )}\r\n                  data-fixed={option.fixed}\r\n                  data-disabled={disabled || undefined}\r\n                >\r\n                  {option.label}\r\n                  <button\r\n                    className={cn(\r\n                      'ml-1 rounded-full outline-none ring-offset-background focus:ring-2 focus:ring-ring focus:ring-offset-2',\r\n                      (disabled || option.fixed) && 'hidden',\r\n                    )}\r\n                    onKeyDown={(e) => {\r\n                      if (e.key === 'Enter') {\r\n                        handleUnselect(option);\r\n                      }\r\n                    }}\r\n                    onMouseDown={(e) => {\r\n                      e.preventDefault();\r\n                      e.stopPropagation();\r\n                    }}\r\n                    onClick={() => handleUnselect(option)}\r\n                  >\r\n                    <X className=\"h-3 w-3 text-muted-foreground hover:text-foreground\" />\r\n                  </button>\r\n                </Badge>\r\n              );\r\n            })}\r\n            {/* Avoid having the \"Search\" Icon */}\r\n            <CommandPrimitive.Input\r\n              {...inputProps}\r\n              ref={inputRef}\r\n              value={inputValue}\r\n              disabled={disabled}\r\n              onValueChange={(value) => {\r\n                setInputValue(value);\r\n                inputProps?.onValueChange?.(value);\r\n              }}\r\n              onBlur={(event) => {\r\n                if (!onScrollbar) {\r\n                  setOpen(false);\r\n                }\r\n                inputProps?.onBlur?.(event);\r\n              }}\r\n              onFocus={(event) => {\r\n                setOpen(true);\r\n                triggerSearchOnFocus && onSearch?.(debouncedSearchTerm);\r\n                inputProps?.onFocus?.(event);\r\n              }}\r\n              placeholder={hidePlaceholderWhenSelected && selected.length !== 0 ? '' : placeholder}\r\n              className={cn(\r\n                'flex-1 bg-transparent outline-none placeholder:text-muted-foreground',\r\n                {\r\n                  'w-full': hidePlaceholderWhenSelected,\r\n                  'px-3 py-2': selected.length === 0,\r\n                  'ml-1': selected.length !== 0,\r\n                },\r\n                inputProps?.className,\r\n              )}\r\n            />\r\n            <button\r\n              type=\"button\"\r\n              onClick={() => {\r\n                setSelected(selected.filter((s) => s.fixed));\r\n                onChange?.(selected.filter((s) => s.fixed));\r\n              }}\r\n              className={cn(\r\n                'absolute right-0 h-6 w-6 p-0',\r\n                (hideClearAllButton ||\r\n                  disabled ||\r\n                  selected.length < 1 ||\r\n                  selected.filter((s) => s.fixed).length === selected.length) &&\r\n                'hidden',\r\n              )}\r\n            >\r\n              <X />\r\n            </button>\r\n          </div>\r\n        </div>\r\n        <div className=\"relative\">\r\n          {open && (\r\n            <CommandList\r\n              className=\"absolute top-1 z-10 w-full rounded-md border bg-popover text-popover-foreground shadow-md outline-none animate-in\"\r\n              onMouseLeave={() => {\r\n                setOnScrollbar(false);\r\n              }}\r\n              onMouseEnter={() => {\r\n                setOnScrollbar(true);\r\n              }}\r\n              onMouseUp={() => {\r\n                inputRef?.current?.focus();\r\n              }}\r\n            >\r\n              {isLoading ? (\r\n                <>{loadingIndicator}</>\r\n              ) : (\r\n                <>\r\n                  {EmptyItem()}\r\n                  {CreatableItem()}\r\n                  {!selectFirstItem && <CommandItem value=\"-\" className=\"hidden\" />}\r\n                  {Object.entries(selectables).map(([key, dropdowns]) => (\r\n                    <CommandGroup key={key} heading={key} className=\"h-full overflow-auto\">\r\n                      <>\r\n                        {dropdowns.map((option) => {\r\n                          return (\r\n                            <CommandItem\r\n                              key={option.value}\r\n                              value={option.value}\r\n                              disabled={option.disable}\r\n                              onMouseDown={(e) => {\r\n                                e.preventDefault();\r\n                                e.stopPropagation();\r\n                              }}\r\n                              onSelect={() => {\r\n                                if (selected.length >= maxSelected) {\r\n                                  onMaxSelected?.(selected.length);\r\n                                  return;\r\n                                }\r\n                                setInputValue('');\r\n                                const newOptions = [...selected, option];\r\n                                setSelected(newOptions);\r\n                                onChange?.(newOptions);\r\n                              }}\r\n                              className={cn(\r\n                                'cursor-pointer',\r\n                                option.disable && 'cursor-default text-muted-foreground',\r\n                              )}\r\n                            >\r\n                              {option.label}\r\n                            </CommandItem>\r\n                          );\r\n                        })}\r\n                      </>\r\n                    </CommandGroup>\r\n                  ))}\r\n                </>\r\n              )}\r\n            </CommandList>\r\n          )}\r\n        </div>\r\n      </Command>\r\n    );\r\n  },\r\n);\r\n\r\nMultipleSelector.displayName = 'MultipleSelector';\r\nexport default MultipleSelector;\r\n",
      "type": "registry:ui",
      "target": "components/spectrumui/multiple-selector-dependencies.tsx"
    }
  ]
}